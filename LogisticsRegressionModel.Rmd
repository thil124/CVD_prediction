---
title: "logistics regression"
author: "Qian Wang"
date: "2025-10-04"
output: html_document
---
```{r}
library(tidyverse)  # 数据处理和可视化
library(caret)      # 模型训练和评估
library(pROC)       # 绘制 ROC 曲线
library(ROSE)       # 处理不平衡数据（SMOTE）
library(vip)        # 计算变量重要性
```

```{r}
df <- read.csv("D:/A_personal/UoA/2025S2/compsci760/CVD_cleaned.csv", stringsAsFactors = FALSE)

dim(df)
str(df)
summary(df)
head(df)
```

# 1.数据预处理
```{r}
# 1.1 目标变量转为因子（保留合法水平）
df$Heart_Disease <- factor(df$Heart_Disease,
                           levels = c("No", "Yes"))  # caret默认识别“第二水平”为阳性类
cat("目标变量水平：", levels(df$Heart_Disease), "\n")

# 1.2 分类特征转为因子
categorical_cols <- c("General_Health", "Checkup", "Exercise", "Skin_Cancer", 
                      "Other_Cancer", "Depression", "Diabetes", "Arthritis", 
                      "Sex", "Age_Category", "Smoking_History")

missing_cols <- setdiff(categorical_cols, colnames(df))
if (length(missing_cols) > 0) {
  stop(paste("以下分类变量不存在：", paste(missing_cols, collapse = ", ")))
}
df[categorical_cols] <- lapply(df[categorical_cols], factor)

# 1.3 独热编码（仅特征）
df_encoded <- dummyVars(Heart_Disease ~ ., data = df, fullRank = TRUE) %>%
  predict(newdata = df) %>%
  as.data.frame() %>%
  mutate(Heart_Disease = df$Heart_Disease)

# 1.4 训练/测试划分
set.seed(123)
train_index <- createDataPartition(df_encoded$Heart_Disease, p = 0.8, list = FALSE)
train_data <- df_encoded[train_index, ]
test_data  <- df_encoded[-train_index, ]
```

# 2.交叉验证与调参
```{r}
train_control <- trainControl(
  method = "cv",
  number = 5,
  search = "random",
  summaryFunction = twoClassSummary,
  classProbs = TRUE,
  savePredictions = "final",
  verboseIter = FALSE
)

tune_grid <- expand.grid(
  alpha = c(0, 1),# 2个可选值（0=岭回归，1=Lasso）
  lambda = exp(seq(-5, 2, length.out = 50))  # 50个可选值（正则化强度）
)
```

# 3. 模型训练
```{r}
# 预处理 + Dummy 编码

# 确保目标变量为因子
train_data$Heart_Disease <- factor(train_data$Heart_Disease, levels = c("No", "Yes"))
test_data$Heart_Disease  <- factor(test_data$Heart_Disease, levels = c("No", "Yes"))

# 清洗列名，防止空格或特殊字符
names(train_data) <- make.names(names(train_data))
names(test_data)  <- make.names(names(test_data))

# dummyVars 编码（保持训练和测试列一致）
dummy_encoder <- dummyVars(Heart_Disease ~ ., data = train_data, fullRank = TRUE)

train_encoded <- predict(dummy_encoder, newdata = train_data) %>% as.data.frame()
train_encoded$Heart_Disease <- train_data$Heart_Disease

test_encoded <- predict(dummy_encoder, newdata = test_data) %>% as.data.frame()
test_encoded$Heart_Disease <- test_data$Heart_Disease

```

```{r}
# 3.1 普通逻辑回归
set.seed(123)
model_logistic <- train(
  x = train_encoded %>% select(-Heart_Disease),
  y = train_encoded$Heart_Disease,
  method = "glmnet",
  tuneGrid = tune_grid,
  trControl = train_control,
  metric = "ROC",
  family = "binomial"
)

```


```{r}
# 3.2 加权逻辑回归
n0 <- sum(train_encoded$Heart_Disease == "No")
n1 <- sum(train_encoded$Heart_Disease == "Yes")
weights <- ifelse(train_encoded$Heart_Disease == "Yes", n0/n1, 1)

set.seed(123)
model_weighted <- train(
  x = train_encoded %>% select(-Heart_Disease),
  y = train_encoded$Heart_Disease,
  method = "glmnet",
  tuneGrid = tune_grid,
  trControl = train_control,
  weights = weights,
  metric = "ROC",
  family = "binomial"
)

```


```{r}
# 3.3 SMOTE + 加权逻辑回归 

# 自动生成公式
formula_safe <- reformulate(setdiff(names(train_encoded), "Heart_Disease"), response = "Heart_Disease")

# ROSE 生成平衡样本
train_smote <- ROSE(formula_safe, data = train_encoded, seed = 123)$data
train_smote$Heart_Disease <- factor(train_smote$Heart_Disease, levels = c("No", "Yes"))

# SMOTE 样本权重
n0_smote <- sum(train_smote$Heart_Disease == "No")
n1_smote <- sum(train_smote$Heart_Disease == "Yes")
weights_smote <- ifelse(train_smote$Heart_Disease == "Yes", n0_smote / n1_smote, 1)

set.seed(123)
model_smote_weighted <- train(
  x = train_smote %>% select(-Heart_Disease),
  y = train_smote$Heart_Disease,
  method = "glmnet",
  tuneGrid = tune_grid,
  trControl = train_control,
  weights = weights_smote,
  metric = "ROC",
  family = "binomial"
)
```

```{r}
cat("原始训练集行数：", nrow(train_encoded), "\n")
print(table(train_encoded$Heart_Disease))  # 看"No"和"Yes"的数量

cat("平衡后行数：", nrow(train_smote), "\n")
print(table(train_smote$Heart_Disease))    # 看平衡后的类别分布
```


# 4. 模型预测与评估

```{r}
actual <- test_data$Heart_Disease

# 对测试集补齐列，保持顺序
feature_cols <- names(train_encoded %>% select(-Heart_Disease))
test_aligned <- test_encoded %>%
  mutate(across(.cols = setdiff(feature_cols, names(.)), .fns = ~0)) %>%
  select(all_of(feature_cols))

feature_cols_smote <- names(train_smote %>% select(-Heart_Disease))
test_aligned_smote <- test_encoded %>%
  mutate(across(.cols = setdiff(feature_cols_smote, names(.)), .fns = ~0)) %>%
  select(all_of(feature_cols_smote))

# 预测概率
pred_logistic       <- predict(model_logistic, test_aligned, type = "prob")[, "Yes"]
pred_weighted       <- predict(model_weighted, test_aligned, type = "prob")[, "Yes"]
pred_smote_weighted <- predict(model_smote_weighted, test_aligned_smote, type = "prob")[, "Yes"]

# 评估函数（英文列名，中文注释）
eval_metrics <- function(pred_prob, actual, threshold) {
  pred <- ifelse(pred_prob > threshold, "Yes", "No")
  cm <- confusionMatrix(factor(pred, levels = c("No", "Yes")), actual, positive = "Yes")
  auc <- roc(actual, pred_prob)$auc
  data.frame(
    Threshold = threshold,          # 阈值
    Accuracy = cm$overall["Accuracy"],  # 准确率
    Precision = cm$byClass["Precision"],# 精确率
    Recall = cm$byClass["Recall"],      # 召回率
    F1_Score = cm$byClass["F1"],        # F1分数
    AUC = as.numeric(auc)               # AUC
  )
}

# 多阈值评估
thresholds <- c(0.3, 0.4, 0.5)
metrics_logistic <- lapply(thresholds, function(t) eval_metrics(pred_logistic, actual, t)) %>%
  bind_rows() %>% mutate(Model = "Logistic Regression")
metrics_weighted <- lapply(thresholds, function(t) eval_metrics(pred_weighted, actual, t)) %>%
  bind_rows() %>% mutate(Model = "Weighted Logistic Regression")
metrics_smote <- lapply(thresholds, function(t) eval_metrics(pred_smote_weighted, actual, t)) %>%
  bind_rows() %>% mutate(Model = "SMOTE + Weighted Logistic Regression")

all_metrics <- bind_rows(metrics_logistic, metrics_weighted, metrics_smote)
cat("=== Model Evaluation Metrics (Different Thresholds) ===\n")
print(all_metrics, digits = 3)


```

# 5. ROC 曲线绘制

```{r}
roc_logistic <- roc(actual, pred_logistic)
roc_weighted <- roc(actual, pred_weighted)
roc_smote    <- roc(actual, pred_smote_weighted)

ggroc(list(
  "Logistic Regression" = roc_logistic,
  "Weighted Logistic Regression" = roc_weighted,
  "SMOTE + Weighted Logistic Regression" = roc_smote
)) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "gray") +
  labs(title = "ROC Curve Comparison", x = "False Positive Rate (FPR)", y = "True Positive Rate (TPR)") +
  theme_minimal()
```

# 6. 不同阈值下的召回率 + 准确率对比

```{r}
# 将数据转长格式
all_metrics_long <- all_metrics %>%
  pivot_longer(
    cols = c(Accuracy, Recall),  
    names_to = "Metric",         
    values_to = "Value"          
  )

ggplot(all_metrics_long, 
       aes(
         x = as.numeric(as.character(Threshold)),  # 转为数值型，支持连线
         y = Value, 
         color = Model,       
         linetype = Metric,   # 实线=Recall，虚线=Accuracy
         shape = Metric,      # 圆=Recall，三角=Accuracy
         group = interaction(Model, Metric)  # 按“模型+指标”分组，确保同组连线
       )) +  
  geom_line(size = 1.2) + 
  geom_point(size = 4, stroke = 1) +  # 点加大
  scale_linetype_manual(
    values = c("Recall" = "solid", "Accuracy" = "dashed"),  
    name = "Metric"
  ) +  
  scale_shape_manual(
    values = c("Recall" = 16, "Accuracy" = 17),  
    name = "Metric"
  ) +  
  theme_minimal() +  
  theme(legend.position = "right") +  
  labs(
    title = "Recall vs. Accuracy Across Thresholds",  
    x = "Prediction Threshold",  
    y = "Value"  
  )

```
# 混淆矩阵
```{r}
# 生成混淆矩阵（按模型+阈值）
generate_confusion_matrices <- function(pred_prob, actual, thresholds, model_name) {
  cm_list <- list()
  for (t in thresholds) {
    # 将概率转为类别（Yes/No）
    pred_class <- ifelse(pred_prob > t, "Yes", "No")  
    # 生成混淆矩阵（指定阳性类为"Yes"）
    cm <- confusionMatrix(
      reference = actual, 
      data = factor(pred_class, levels = c("No", "Yes")), 
      positive = "Yes"
    )
    cm_list[[paste0(model_name, "_Threshold_", t)]] <- cm
  }
  return(cm_list)
}

# 对三个模型分别生成混淆矩阵
cm_logistic <- generate_confusion_matrices(pred_logistic, actual, thresholds, "Logistic Regression")
cm_weighted <- generate_confusion_matrices(pred_weighted, actual, thresholds, "Weighted Logistic Regression")
cm_smote    <- generate_confusion_matrices(pred_smote_weighted, actual, thresholds, "SMOTE + Weighted Logistic Regression")

# 打印混淆矩阵（按需选择打印或保存）
cat("\n=== Logistic Regression 混淆矩阵（不同阈值） ===\n")
for (name in names(cm_logistic)) {
  cat("\n>>>", name, "<<<\n")
  print(cm_logistic[[name]])
}

cat("\n=== Weighted Logistic Regression 混淆矩阵（不同阈值） ===\n")
for (name in names(cm_weighted)) {
  cat("\n>>>", name, "<<<\n")
  print(cm_weighted[[name]])
}

cat("\n=== SMOTE + Weighted Logistic Regression 混淆矩阵（不同阈值） ===\n")
for (name in names(cm_smote)) {
  cat("\n>>>", name, "<<<\n")
  print(cm_smote[[name]])
}
```


# 7. 变量重要性分析（系数绝对值）
```{r}
var_imp <- function(model) {
  coefs <- coef(model$finalModel, model$bestTune$lambda) %>%
    as.matrix() %>% as.data.frame() %>%
    rownames_to_column("Variable") %>%
    setNames(c("Variable", "Importance")) %>%
    filter(Variable != "(Intercept)") %>%
    mutate(Importance = abs(Importance)) %>%
    arrange(desc(Importance))
  return(coefs)
}

# 提取三模型变量重要性
imp_logistic <- var_imp(model_logistic) %>% mutate(Model = "Logistic Regression")
imp_weighted <- var_imp(model_weighted) %>% mutate(Model = "Weighted Logistic Regression")
imp_smote    <- var_imp(model_smote_weighted) %>% mutate(Model = "SMOTE + Weighted Logistic Regression")

# 打印 Top10
cat("\n=== Logistic Regression Top10 Variable Importance ===\n")
print(head(imp_logistic, 10), digits = 3)
cat("\n=== Weighted Logistic Regression Top10 Variable Importance ===\n")
print(head(imp_weighted, 10), digits = 3)
cat("\n=== SMOTE + Weighted Logistic Regression Top10 Variable Importance ===\n")
print(head(imp_smote, 10), digits = 3)

# 绘制 Top10 图
plot_top10 <- function(imp_df, title) {
  imp_df %>% head(10) %>%
    ggplot(aes(x = reorder(Variable, Importance), y = Importance)) +
    geom_bar(stat = "identity", fill = "#1E90FF") +
    coord_flip() +
    labs(title = title, x = "Variable", y = "Importance (|Coefficient|)") +
    theme_minimal()
}

plot_top10(imp_logistic, "Logistic Regression Top10 Variable Importance")
plot_top10(imp_weighted, "Weighted Logistic Regression Top10 Variable Importance")
plot_top10(imp_smote, "SMOTE + Weighted Logistic Regression Top10 Variable Importance")

```



# 7-2. 变量重要性分析（合并）
```{r}
# 加载必要库（确保stringr已安装）
library(tidyverse)
library(stringr)  # 用于字符串处理

# 定义变量重要性函数（合并同一原始变量的类别）
var_imp <- function(model) {
  coefs <- coef(model$finalModel, model$bestTune$lambda) %>%
    as.matrix() %>% as.data.frame() %>%
    rownames_to_column("Variable") %>%
    setNames(c("Variable", "Importance")) %>%
    filter(Variable != "(Intercept)") %>%  # 排除截距
    mutate(
      Importance = abs(Importance),         # 系数绝对值
      # 提取原始变量名（拆分".", 取前缀）
      Original_Variable = str_extract(Variable, "^[^\\.]+")
    ) %>%
    group_by(Original_Variable) %>%         # 按原始变量分组
    summarise(Importance = sum(Importance), # 合并重要性（求和）
              .groups = "drop") %>%
    arrange(desc(Importance))               # 降序排列
  return(coefs)
}

# 提取三模型的合并后变量重要性
imp_logistic <- var_imp(model_logistic) %>% mutate(Model = "Logistic Regression")
imp_weighted <- var_imp(model_weighted) %>% mutate(Model = "Weighted Logistic Regression")
imp_smote    <- var_imp(model_smote_weighted) %>% mutate(Model = "SMOTE + Weighted Logistic Regression")

# 打印 Top10（合并后）
cat("\n=== Logistic Regression Top10 Variable Importance（合并后） ===\n")
print(head(imp_logistic, 10), digits = 3)
cat("\n=== Weighted Logistic Regression Top10 Variable Importance（合并后） ===\n")
print(head(imp_weighted, 10), digits = 3)
cat("\n=== SMOTE + Weighted Logistic Regression Top10 Variable Importance（合并后） ===\n")
print(head(imp_smote, 10), digits = 3)

# 绘制 Top10 图（合并后变量）
plot_top10 <- function(imp_df, title) {
  imp_df %>% head(10) %>%
    ggplot(aes(x = reorder(Original_Variable, Importance), y = Importance)) +
    geom_bar(stat = "identity", fill = "#1E90FF") +
    coord_flip() +
    labs(title = title, 
         x = "Variable", 
         y = "Importance (Sum of |Coefficients|)") +  # 说明是系数和
    theme_minimal()
}

# 绘制三张图
plot_top10(imp_logistic, "Logistic Regression Top10 Variable Importance（合并后）")
plot_top10(imp_weighted, "Weighted Logistic Regression Top10 Variable Importance（合并后）")
plot_top10(imp_smote, "SMOTE + Weighted Logistic Regression Top10 Variable Importance（合并后）")

```

# 8. 提取最优参数 + 构建 logit 方程

```{r}

print_model_details <- function(model, model_name) {
  # 1️⃣ 最优超参数
  best_params <- model$bestTune
  cat("\n=== ", model_name, " Best Hyperparameters ===\n")
  print(best_params)
  
  # 2️⃣ 提取最优 lambda 下的系数
  coefs <- coef(model$finalModel, s = best_params$lambda)
  coefs <- as.matrix(coefs)
  coefs_df <- data.frame(
    Variable = rownames(coefs),
    Coefficient = coefs[,1],  # 始终取第一列
    stringsAsFactors = FALSE
  )
  
  # 3️⃣ 分离截距和特征系数（明确指定数据框）
  intercept <- dplyr::filter(coefs_df, Variable == "(Intercept)")$Coefficient
  intercept <- round(intercept, 3)
  
  feature_coefs <- dplyr::filter(coefs_df, Variable != "(Intercept)")
  feature_coefs$Coefficient <- round(feature_coefs$Coefficient, 3)
  
  # 4️⃣ 构建 logit 公式
  formula_str <- paste0("logit(P(Heart_Disease='Yes')) = ", intercept, " + ")
  for(i in 1:nrow(feature_coefs)) {
    formula_str <- paste0(formula_str, feature_coefs$Coefficient[i], " * ", feature_coefs$Variable[i], " + ")
  }
  formula_str <- substr(formula_str, 1, nchar(formula_str)-3)  # 去掉最后 " + "
  
  cat("\n=== ", model_name, " Logit Equation ===\n")
  cat(formula_str, "\n\n")
}

# 调用示例
print_model_details(model_logistic, "Logistic Regression")
print_model_details(model_weighted, "Weighted Logistic Regression")
print_model_details(model_smote_weighted, "SMOTE + Weighted Logistic Regression")

```


